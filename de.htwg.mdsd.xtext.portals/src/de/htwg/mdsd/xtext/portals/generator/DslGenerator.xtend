/*
 * generated by Xtext
 */
package de.htwg.mdsd.xtext.portals.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import de.htwg.mdsd.xtext.portals.dsl.Terrain
import de.htwg.mdsd.xtext.portals.dsl.Game
import org.eclipse.emf.common.util.EList
import de.htwg.mdsd.xtext.portals.dsl.Player
import de.htwg.mdsd.xtext.portals.dsl.Bot

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DslGenerator implements IGenerator {

	var packageName = "de.htwg.mps.portals";

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val game = resource.contents.filter(typeof(Game)).head

		val packagePath = "de\\htwg\\mps\\portals\\" //+ game.name.toFirstLower
		packageName = packageName //+ game.name.toFirstLower

		fsa.generateFile(packagePath + "\\model\\Terrain.scala", generateTerrains(game.terrains))
		fsa.generateFile(packagePath + "\\model\\Human.scala", generatePlayer(game.player))
		fsa.generateFile(packagePath + "\\model\\Bots.scala", generateBots(game.bots))
		fsa.generateFile(packagePath + "\\model\\PlayerFactory.scala", generatePlayerFactory(game.player, game.bots))
		fsa.generateFile(packagePath + "\\swing\\PlayerSprites.scala", generatePlayerSprites(game.player, game.bots))
		fsa.generateFile(packagePath + "\\swing\\TerrainSprite.scala", generateTerrainSprites(game.terrains))
	}
	
	def generateTerrainSprites(EList<Terrain> terrains) {'''
	package «packageName».swing
	
	import de.htwg.mps.portals.model._
	import de.htwg.mps.portals.swing.util._
	
	object TerrainSprite {
	  def apply(terrain : Terrain) : TerrainSprite = terrain match {
        «FOR terrain : terrains»
	    case «terrain.name» 	=> new «terrain.name»Sprite
		«ENDFOR»
	  }
	}
	
	trait TerrainSprite {
	  def sprite : Sprite
	}
    «FOR terrain : terrains»
	class «terrain.name»Sprite extends TerrainSprite {
	  val sprite = new Sprite ("/sprite/default/«terrain.image».png", 32, 32, 0, 0)
	}
	«ENDFOR»
		
	'''
	}
	
	def generatePlayerSprites(Player player, EList<Bot> bots) {''' 
		package «packageName».swing
		
		import scala.concurrent.ExecutionContext.Implicits.global
		import scala.concurrent.Future
		import scala.concurrent.duration._
		import de.htwg.mps.portals.model.Player
		import de.htwg.mps.portals.swing.util._
		import de.htwg.mps.portals.swing.PlayerSprite
		import de.htwg.mps.portals.model._
		
		// companion object to get Terrain instances, like a factory method.
		object PlayerSprites {
		  def apply(player : Player) : PlayerSprite = player match {
		    case Human(_,_,_,_) => new «player.name»Sprite
        «FOR bot : bots»
			case «bot.name»(_,_,_,_,_) => new «bot.name»Sprite
		«ENDFOR»
		  }
		}
		
		class «player.name»Sprite extends PlayerSprite {
		  val image = "/sprite/default/player/«player.color».png"
		}
		
        «FOR bot : bots»
		class «bot.name»Sprite extends PlayerSprite {
		  val image = "/sprite/default/player/«bot.color».png"
		}
		«ENDFOR»
		'''
	}
	
	def generatePlayerFactory(Player player, EList<Bot> bots) { '''
		package «packageName».model
	
		// companion object to get Terrain instances, like a factory method.
		object PlayerFactory {
		  def HumanPlayer1 = "«player.symbol»"
		
		  def apply(char: Char, position: Position): Option[Player] = char match {
		    case '«player.symbol»' =>
		      Some(Human(HumanPlayer1, position, Stay, 0))
	        «FOR bot : bots»
			case '«bot.symbol»' =>
				val id = java.util.UUID.randomUUID.toString
		        Some(«bot.name.toFirstUpper»(id, position, Up, Stay, 0))
			«ENDFOR»
		    case _ => None
		  }
		}
	'''
	}
	
	
	def CharSequence generateBots(EList<Bot> bots) { '''
		package «packageName».model
		
		«FOR bot : bots»
			case class «bot.name.toFirstUpper»(
			  override val uuid : String,
			  override val position : Position,
			  override val direction : Direction,
			  val lastValid : Direction,
			  override val movementCost : Int) extends Bot {
				override def toString = "«bot.symbol»"
				override def destroy(player : Player) = player match {
				  	case (player : Human) => «bot.endGame»
					«FOR player : bot.destroy»
					case (player : «player.name.toFirstUpper») => true
	    			«ENDFOR»
					case _ => false
				}
				def validMove(movementCost : Int) = new «bot.name.toFirstUpper»(uuid, nextPosition, direction, direction, movementCost)
				def invalidMove = new «bot.name.toFirstUpper»(uuid, position, switchDirection(lastValid, direction), direction, movementCost)
				def paiyMovementCost() = new «bot.name.toFirstUpper»(uuid, position, direction, direction, movementCost - «bot.speed»)
			}
			
		«ENDFOR»
	'''
	}

	def CharSequence generatePlayer(Player player) {
		'''
		package «packageName».model
		
		case class Human(
			   override val uuid : String, 
			   override val position : Position,
			   override val direction : Direction,
			   override val movementCost : Int) extends Player {
			override def toString = "«player.symbol»"
			def switchDirection(direction : Direction) = new Human(uuid, position, direction, movementCost)
			def validMove(movementCost : Int) = new Human(uuid, nextPosition, direction, movementCost)
			def invalidMove = new Human(uuid, position, Stay, movementCost)
			def paiyMovementCost() = new Human(uuid, position, direction, movementCost - «player.speed»);
			override def destroy(player : Player) = player match {
				«FOR bot : player.destroy»
				case (player : «bot.name.toFirstUpper») => true
    			«ENDFOR»
				case _ => false
			}
		}
	'''
	}

	def CharSequence generateTerrains(EList<Terrain> terrains) {
		'''
			package «packageName».model
			
			sealed trait Terrain {
			  def walkableBy(player : Player) = false
			  def endGame = false
			  def movementCost = 0
			  def toString : String
			}
			
			// companion object to get Terrain instances, like a factory method.
			object Terrain {
			  def apply(char : Char) = char match {
			«FOR terrain : terrains»
				case '«terrain.symbol»' => «terrain.name.toFirstUpper»
			«ENDFOR»
			  }
			}
			
			«FOR terrain : terrains»
				case object «terrain.name.toFirstUpper» extends Terrain {
				  override def toString = "«terrain.symbol»"
				  override def movementCost = «terrain.movementCost»
				  override def endGame = «terrain.endGame»
				  override def walkableBy(player : Player) = player match {
				    case _ : Human => «terrain.playerWalkable»
				    «FOR bot : terrain.bots»
				    	case _ : «bot.name.toFirstUpper» => true
				    «ENDFOR»
				    case _		   => false
				  }
				}
			«ENDFOR»
		'''
	}

}
